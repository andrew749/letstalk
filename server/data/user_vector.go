// Code generated by ModelQ
// user_vector.go contains model for the database table [letstalk.user_vector]

package data

import (
	"database/sql"
	"encoding/gob"
	"encoding/json"
	"fmt"
	"github.com/mijia/modelq/gmq"
	"strings"
)

type UserVector struct {
	UserId         int `json:"user_id"`
	PreferenceType int `json:"preference_type"`
	Sociable       int `json:"sociable"`
	HardWorking    int `json:"hard_working"`
	Ambitious      int `json:"ambitious"`
	Energetic      int `json:"energetic"`
	Carefree       int `json:"carefree"`
	Confident      int `json:"confident"`
}

// Start of the UserVector APIs.

func (obj UserVector) String() string {
	if data, err := json.Marshal(obj); err != nil {
		return fmt.Sprintf("<UserVector UserId=%v>", obj.UserId)
	} else {
		return string(data)
	}
}

func (obj UserVector) Get(dbtx gmq.DbTx) (UserVector, error) {
	filter := UserVectorObjs.FilterUserId("=", obj.UserId)
	if result, err := UserVectorObjs.Select().Where(filter).One(dbtx); err != nil {
		return obj, err
	} else {
		return result, nil
	}
}

func (obj UserVector) Insert(dbtx gmq.DbTx) (UserVector, error) {
	_, err := UserVectorObjs.Insert(obj).Run(dbtx)
	return obj, err
}

func (obj UserVector) Update(dbtx gmq.DbTx) (int64, error) {
	fields := []string{"PreferenceType", "Sociable", "HardWorking", "Ambitious", "Energetic", "Carefree", "Confident"}
	filter := UserVectorObjs.FilterUserId("=", obj.UserId)
	if result, err := UserVectorObjs.Update(obj, fields...).Where(filter).Run(dbtx); err != nil {
		return 0, err
	} else {
		return result.RowsAffected()
	}
}

func (obj UserVector) Delete(dbtx gmq.DbTx) (int64, error) {
	filter := UserVectorObjs.FilterUserId("=", obj.UserId)
	if result, err := UserVectorObjs.Delete().Where(filter).Run(dbtx); err != nil {
		return 0, err
	} else {
		return result.RowsAffected()
	}
}

// Start of the inner Query Api

type _UserVectorQuery struct {
	gmq.Query
}

func (q _UserVectorQuery) Where(f gmq.Filter) _UserVectorQuery {
	q.Query = q.Query.Where(f)
	return q
}

func (q _UserVectorQuery) OrderBy(by ...string) _UserVectorQuery {
	tBy := make([]string, 0, len(by))
	for _, b := range by {
		sortDir := ""
		if b[0] == '-' || b[0] == '+' {
			sortDir = string(b[0])
			b = b[1:]
		}
		if col, ok := UserVectorObjs.fcMap[b]; ok {
			tBy = append(tBy, sortDir+col)
		}
	}
	q.Query = q.Query.OrderBy(tBy...)
	return q
}

func (q _UserVectorQuery) GroupBy(by ...string) _UserVectorQuery {
	tBy := make([]string, 0, len(by))
	for _, b := range by {
		if col, ok := UserVectorObjs.fcMap[b]; ok {
			tBy = append(tBy, col)
		}
	}
	q.Query = q.Query.GroupBy(tBy...)
	return q
}

func (q _UserVectorQuery) Limit(offsets ...int64) _UserVectorQuery {
	q.Query = q.Query.Limit(offsets...)
	return q
}

func (q _UserVectorQuery) Page(number, size int) _UserVectorQuery {
	q.Query = q.Query.Page(number, size)
	return q
}

func (q _UserVectorQuery) Run(dbtx gmq.DbTx) (sql.Result, error) {
	return q.Query.Exec(dbtx)
}

type UserVectorRowVisitor func(obj UserVector) bool

func (q _UserVectorQuery) Iterate(dbtx gmq.DbTx, functor UserVectorRowVisitor) error {
	return q.Query.SelectList(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		obj := UserVectorObjs.toUserVector(columns, rb)
		return functor(obj)
	})
}

func (q _UserVectorQuery) One(dbtx gmq.DbTx) (UserVector, error) {
	var obj UserVector
	err := q.Query.SelectOne(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		obj = UserVectorObjs.toUserVector(columns, rb)
		return true
	})
	return obj, err
}

func (q _UserVectorQuery) List(dbtx gmq.DbTx) ([]UserVector, error) {
	result := make([]UserVector, 0, 10)
	err := q.Query.SelectList(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		obj := UserVectorObjs.toUserVector(columns, rb)
		result = append(result, obj)
		return true
	})
	return result, err
}

func (q _UserVectorQuery) Count(dbtx gmq.DbTx) (int, error) {
	result := 0

	err := q.Query.SelectCount(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		if len(columns) == len(rb) {
			for i := range columns {
				if "_count" == columns[i].Name {
					result = gmq.AsInt(rb[i])

					return true
				}
			}
		}

		return true
	})

	return result, err
}

// Start of the model facade Apis.

type _UserVectorObjs struct {
	fcMap map[string]string
}

func (o _UserVectorObjs) Names() (schema, tbl, alias string) {
	return "letstalk", "user_vector", "UserVector"
}

func (o _UserVectorObjs) Select(fields ...string) _UserVectorQuery {
	q := _UserVectorQuery{}
	if len(fields) == 0 {
		fields = []string{"UserId", "PreferenceType", "Sociable", "HardWorking", "Ambitious", "Energetic", "Carefree", "Confident"}
	}
	q.Query = gmq.Select(o, o.columns(fields...))
	return q
}

func (o _UserVectorObjs) Insert(obj UserVector) _UserVectorQuery {
	q := _UserVectorQuery{}
	q.Query = gmq.Insert(o, o.columnsWithData(obj, "UserId", "PreferenceType", "Sociable", "HardWorking", "Ambitious", "Energetic", "Carefree", "Confident"))
	return q
}

func (o _UserVectorObjs) Update(obj UserVector, fields ...string) _UserVectorQuery {
	q := _UserVectorQuery{}
	q.Query = gmq.Update(o, o.columnsWithData(obj, fields...))
	return q
}

func (o _UserVectorObjs) Delete() _UserVectorQuery {
	q := _UserVectorQuery{}
	q.Query = gmq.Delete(o)
	return q
}

///// Managed Objects Filters definition

func (o _UserVectorObjs) FilterUserId(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("user_id", op, params...)
}

func (o _UserVectorObjs) FilterPreferenceType(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("preference_type", op, params...)
}

func (o _UserVectorObjs) FilterSociable(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("sociable", op, params...)
}

func (o _UserVectorObjs) FilterHardWorking(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("hard_working", op, params...)
}

func (o _UserVectorObjs) FilterAmbitious(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("ambitious", op, params...)
}

func (o _UserVectorObjs) FilterEnergetic(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("energetic", op, params...)
}

func (o _UserVectorObjs) FilterCarefree(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("carefree", op, params...)
}

func (o _UserVectorObjs) FilterConfident(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("confident", op, params...)
}

///// Managed Objects Columns definition

func (o _UserVectorObjs) ColumnUserId(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"user_id", value}
}

func (o _UserVectorObjs) ColumnPreferenceType(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"preference_type", value}
}

func (o _UserVectorObjs) ColumnSociable(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"sociable", value}
}

func (o _UserVectorObjs) ColumnHardWorking(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"hard_working", value}
}

func (o _UserVectorObjs) ColumnAmbitious(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"ambitious", value}
}

func (o _UserVectorObjs) ColumnEnergetic(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"energetic", value}
}

func (o _UserVectorObjs) ColumnCarefree(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"carefree", value}
}

func (o _UserVectorObjs) ColumnConfident(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"confident", value}
}

////// Internal helper funcs

func (o _UserVectorObjs) newFilter(name, op string, params ...interface{}) gmq.Filter {
	if strings.ToUpper(op) == "IN" {
		return gmq.InFilter(name, params)
	}
	return gmq.UnitFilter(name, op, params[0])
}

func (o _UserVectorObjs) toUserVector(columns []gmq.Column, rb []sql.RawBytes) UserVector {
	obj := UserVector{}
	if len(columns) == len(rb) {
		for i := range columns {
			switch columns[i].Name {
			case "user_id":
				obj.UserId = gmq.AsInt(rb[i])
			case "preference_type":
				obj.PreferenceType = gmq.AsInt(rb[i])
			case "sociable":
				obj.Sociable = gmq.AsInt(rb[i])
			case "hard_working":
				obj.HardWorking = gmq.AsInt(rb[i])
			case "ambitious":
				obj.Ambitious = gmq.AsInt(rb[i])
			case "energetic":
				obj.Energetic = gmq.AsInt(rb[i])
			case "carefree":
				obj.Carefree = gmq.AsInt(rb[i])
			case "confident":
				obj.Confident = gmq.AsInt(rb[i])
			}
		}
	}
	return obj
}

func (o _UserVectorObjs) columns(fields ...string) []gmq.Column {
	data := make([]gmq.Column, 0, len(fields))
	for _, f := range fields {
		switch f {
		case "UserId":
			data = append(data, o.ColumnUserId())
		case "PreferenceType":
			data = append(data, o.ColumnPreferenceType())
		case "Sociable":
			data = append(data, o.ColumnSociable())
		case "HardWorking":
			data = append(data, o.ColumnHardWorking())
		case "Ambitious":
			data = append(data, o.ColumnAmbitious())
		case "Energetic":
			data = append(data, o.ColumnEnergetic())
		case "Carefree":
			data = append(data, o.ColumnCarefree())
		case "Confident":
			data = append(data, o.ColumnConfident())
		}
	}
	return data
}

func (o _UserVectorObjs) columnsWithData(obj UserVector, fields ...string) []gmq.Column {
	data := make([]gmq.Column, 0, len(fields))
	for _, f := range fields {
		switch f {
		case "UserId":
			data = append(data, o.ColumnUserId(obj.UserId))
		case "PreferenceType":
			data = append(data, o.ColumnPreferenceType(obj.PreferenceType))
		case "Sociable":
			data = append(data, o.ColumnSociable(obj.Sociable))
		case "HardWorking":
			data = append(data, o.ColumnHardWorking(obj.HardWorking))
		case "Ambitious":
			data = append(data, o.ColumnAmbitious(obj.Ambitious))
		case "Energetic":
			data = append(data, o.ColumnEnergetic(obj.Energetic))
		case "Carefree":
			data = append(data, o.ColumnCarefree(obj.Carefree))
		case "Confident":
			data = append(data, o.ColumnConfident(obj.Confident))
		}
	}
	return data
}

var UserVectorObjs _UserVectorObjs

func init() {
	UserVectorObjs.fcMap = map[string]string{
		"UserId":         "user_id",
		"PreferenceType": "preference_type",
		"Sociable":       "sociable",
		"HardWorking":    "hard_working",
		"Ambitious":      "ambitious",
		"Energetic":      "energetic",
		"Carefree":       "carefree",
		"Confident":      "confident",
	}
	gob.Register(UserVector{})
}
