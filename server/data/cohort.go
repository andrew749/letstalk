// Code generated by ModelQ
// cohort.go contains model for the database table [letstalk.cohort]

package data

import (
	"database/sql"
	"encoding/gob"
	"encoding/json"
	"fmt"
	"github.com/mijia/modelq/gmq"
	"strings"
)

type Cohort struct {
	CohortId  int    `json:"cohort_id"`
	ProgramId string `json:"program_id"`
	GradYear  int    `json:"grad_year"`
	Sequence  string `json:"sequence"`
}

// Start of the Cohort APIs.

func (obj Cohort) String() string {
	if data, err := json.Marshal(obj); err != nil {
		return fmt.Sprintf("<Cohort CohortId=%v>", obj.CohortId)
	} else {
		return string(data)
	}
}

func (obj Cohort) Get(dbtx gmq.DbTx) (Cohort, error) {
	filter := CohortObjs.FilterCohortId("=", obj.CohortId)
	if result, err := CohortObjs.Select().Where(filter).One(dbtx); err != nil {
		return obj, err
	} else {
		return result, nil
	}
}

func (obj Cohort) Insert(dbtx gmq.DbTx) (Cohort, error) {
	if result, err := CohortObjs.Insert(obj).Run(dbtx); err != nil {
		return obj, err
	} else {
		if dbtx.DriverName() != "postgres" {
			if id, err := result.LastInsertId(); err != nil {
				return obj, err
			} else {
				obj.CohortId = int(id)
				return obj, err
			}
		}
		return obj, nil
	}
}

func (obj Cohort) Update(dbtx gmq.DbTx) (int64, error) {
	fields := []string{"ProgramId", "GradYear", "Sequence"}
	filter := CohortObjs.FilterCohortId("=", obj.CohortId)
	if result, err := CohortObjs.Update(obj, fields...).Where(filter).Run(dbtx); err != nil {
		return 0, err
	} else {
		return result.RowsAffected()
	}
}

func (obj Cohort) Delete(dbtx gmq.DbTx) (int64, error) {
	filter := CohortObjs.FilterCohortId("=", obj.CohortId)
	if result, err := CohortObjs.Delete().Where(filter).Run(dbtx); err != nil {
		return 0, err
	} else {
		return result.RowsAffected()
	}
}

// Start of the inner Query Api

type _CohortQuery struct {
	gmq.Query
}

func (q _CohortQuery) Where(f gmq.Filter) _CohortQuery {
	q.Query = q.Query.Where(f)
	return q
}

func (q _CohortQuery) OrderBy(by ...string) _CohortQuery {
	tBy := make([]string, 0, len(by))
	for _, b := range by {
		sortDir := ""
		if b[0] == '-' || b[0] == '+' {
			sortDir = string(b[0])
			b = b[1:]
		}
		if col, ok := CohortObjs.fcMap[b]; ok {
			tBy = append(tBy, sortDir+col)
		}
	}
	q.Query = q.Query.OrderBy(tBy...)
	return q
}

func (q _CohortQuery) GroupBy(by ...string) _CohortQuery {
	tBy := make([]string, 0, len(by))
	for _, b := range by {
		if col, ok := CohortObjs.fcMap[b]; ok {
			tBy = append(tBy, col)
		}
	}
	q.Query = q.Query.GroupBy(tBy...)
	return q
}

func (q _CohortQuery) Limit(offsets ...int64) _CohortQuery {
	q.Query = q.Query.Limit(offsets...)
	return q
}

func (q _CohortQuery) Page(number, size int) _CohortQuery {
	q.Query = q.Query.Page(number, size)
	return q
}

func (q _CohortQuery) Run(dbtx gmq.DbTx) (sql.Result, error) {
	return q.Query.Exec(dbtx)
}

type CohortRowVisitor func(obj Cohort) bool

func (q _CohortQuery) Iterate(dbtx gmq.DbTx, functor CohortRowVisitor) error {
	return q.Query.SelectList(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		obj := CohortObjs.toCohort(columns, rb)
		return functor(obj)
	})
}

func (q _CohortQuery) One(dbtx gmq.DbTx) (Cohort, error) {
	var obj Cohort
	err := q.Query.SelectOne(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		obj = CohortObjs.toCohort(columns, rb)
		return true
	})
	return obj, err
}

func (q _CohortQuery) List(dbtx gmq.DbTx) ([]Cohort, error) {
	result := make([]Cohort, 0, 10)
	err := q.Query.SelectList(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		obj := CohortObjs.toCohort(columns, rb)
		result = append(result, obj)
		return true
	})
	return result, err
}

func (q _CohortQuery) Count(dbtx gmq.DbTx) (int, error) {
	result := 0

	err := q.Query.SelectCount(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		if len(columns) == len(rb) {
			for i := range columns {
				if "_count" == columns[i].Name {
					result = gmq.AsInt(rb[i])

					return true
				}
			}
		}

		return true
	})

	return result, err
}

// Start of the model facade Apis.

type _CohortObjs struct {
	fcMap map[string]string
}

func (o _CohortObjs) Names() (schema, tbl, alias string) {
	return "letstalk", "cohort", "Cohort"
}

func (o _CohortObjs) Select(fields ...string) _CohortQuery {
	q := _CohortQuery{}
	if len(fields) == 0 {
		fields = []string{"CohortId", "ProgramId", "GradYear", "Sequence"}
	}
	q.Query = gmq.Select(o, o.columns(fields...))
	return q
}

func (o _CohortObjs) Insert(obj Cohort) _CohortQuery {
	q := _CohortQuery{}
	q.Query = gmq.Insert(o, o.columnsWithData(obj, "ProgramId", "GradYear", "Sequence"))
	return q
}

func (o _CohortObjs) Update(obj Cohort, fields ...string) _CohortQuery {
	q := _CohortQuery{}
	q.Query = gmq.Update(o, o.columnsWithData(obj, fields...))
	return q
}

func (o _CohortObjs) Delete() _CohortQuery {
	q := _CohortQuery{}
	q.Query = gmq.Delete(o)
	return q
}

///// Managed Objects Filters definition

func (o _CohortObjs) FilterCohortId(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("cohort_id", op, params...)
}

func (o _CohortObjs) FilterProgramId(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("program_id", op, params...)
}

func (o _CohortObjs) FilterGradYear(op string, p int, ps ...int) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("grad_year", op, params...)
}

func (o _CohortObjs) FilterSequence(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("sequence", op, params...)
}

///// Managed Objects Columns definition

func (o _CohortObjs) ColumnCohortId(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"cohort_id", value}
}

func (o _CohortObjs) ColumnProgramId(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"program_id", value}
}

func (o _CohortObjs) ColumnGradYear(p ...int) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"grad_year", value}
}

func (o _CohortObjs) ColumnSequence(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"sequence", value}
}

////// Internal helper funcs

func (o _CohortObjs) newFilter(name, op string, params ...interface{}) gmq.Filter {
	if strings.ToUpper(op) == "IN" {
		return gmq.InFilter(name, params)
	}
	return gmq.UnitFilter(name, op, params[0])
}

func (o _CohortObjs) toCohort(columns []gmq.Column, rb []sql.RawBytes) Cohort {
	obj := Cohort{}
	if len(columns) == len(rb) {
		for i := range columns {
			switch columns[i].Name {
			case "cohort_id":
				obj.CohortId = gmq.AsInt(rb[i])
			case "program_id":
				obj.ProgramId = gmq.AsString(rb[i])
			case "grad_year":
				obj.GradYear = gmq.AsInt(rb[i])
			case "sequence":
				obj.Sequence = gmq.AsString(rb[i])
			}
		}
	}
	return obj
}

func (o _CohortObjs) columns(fields ...string) []gmq.Column {
	data := make([]gmq.Column, 0, len(fields))
	for _, f := range fields {
		switch f {
		case "CohortId":
			data = append(data, o.ColumnCohortId())
		case "ProgramId":
			data = append(data, o.ColumnProgramId())
		case "GradYear":
			data = append(data, o.ColumnGradYear())
		case "Sequence":
			data = append(data, o.ColumnSequence())
		}
	}
	return data
}

func (o _CohortObjs) columnsWithData(obj Cohort, fields ...string) []gmq.Column {
	data := make([]gmq.Column, 0, len(fields))
	for _, f := range fields {
		switch f {
		case "CohortId":
			data = append(data, o.ColumnCohortId(obj.CohortId))
		case "ProgramId":
			data = append(data, o.ColumnProgramId(obj.ProgramId))
		case "GradYear":
			data = append(data, o.ColumnGradYear(obj.GradYear))
		case "Sequence":
			data = append(data, o.ColumnSequence(obj.Sequence))
		}
	}
	return data
}

var CohortObjs _CohortObjs

func init() {
	CohortObjs.fcMap = map[string]string{
		"CohortId":  "cohort_id",
		"ProgramId": "program_id",
		"GradYear":  "grad_year",
		"Sequence":  "sequence",
	}
	gob.Register(Cohort{})
}
